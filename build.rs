use std::env;
use std::ffi::OsStr;
use std::io;
use std::process::{exit, Command, Output, Stdio};
use std::str;

/// The version of the Yang that will be used to generate build files.
const YANG_DEP_VERSION: &str = "0.0.11";

/// The filename extension for the yang executable.
#[cfg(target_family = "unix")]
const BINARY_EXT: &str = "";
#[cfg(target_family = "windows")]
const BINARY_EXT: &str = ".exe";

/// Call out to the commandline.
fn run_command<I, S>(streaming: bool, command: &str, args: I) -> io::Result<Output>
where
    I: IntoIterator<Item = S>,
    S: AsRef<OsStr>,
{
    let mut command = Command::new(command);
    if streaming {
        command.stdout(Stdio::inherit()).stderr(Stdio::inherit());
    }
    command.args(args).output()
}

/// Run a command and assert that it succeeded.
fn assert_command<I, S>(streaming: bool, command: &str, args: I)
where
    I: IntoIterator<Item = S>,
    S: AsRef<OsStr>,
{
    assert!(run_command(streaming, command, args)
        .unwrap()
        .status
        .success());
}

fn yang_path() -> String {
    match env::var("YANG_DEV_DIR") {
        Ok(dev_dir) => {
            // custom paths useful when developing on a future yang version
            let custom_path = format!("{}/target/debug/yang{}", dev_dir, BINARY_EXT);
            println!("Custom path for yang binary set to {}", custom_path);
            custom_path
        }
        Err(_) => {
            // somehow Cargo seems to add the target output directory to the PATH during builds,
            // because the "yang" command returns the latest built binary after it's been built the // first time
            format!("{}/bin/yang", env::var("CARGO_HOME").unwrap())
        }
    }
}

fn check_yang_version() -> bool {
    let yang_binary = yang_path();
    match run_command(false, &yang_binary, vec!["--help"]) {
        Ok(output) => {
            let version_str = format!("yang {}", YANG_DEP_VERSION);
            let output_str = str::from_utf8(&output.stdout).unwrap();
            let verified = output.status.success() && output_str.contains(&version_str);
            if verified {
                println!(
                    "Verified that yang v{} is installed at {}",
                    YANG_DEP_VERSION, yang_binary
                );
            } else {
                println!(
                    "yang at {} is still a different version than v{}",
                    yang_binary, YANG_DEP_VERSION
                );
            }
            verified
        }
        Err(_) => {
            println!("No yang binary found at {}", yang_binary);
            false
        }
    }
}

/// Make sure the right version of yang is installed.
fn ensure_yang_installed() {
    // only check yang version if custom binary is not provided
    if env::var("YANG_DEV_DIR").is_err() && !check_yang_version() {
        println!("Installing yang v{} ...", YANG_DEP_VERSION);
        assert_command(
            true,
            "cargo",
            vec![
                "install",
                "--version",
                YANG_DEP_VERSION,
                "--force",
                "--",
                "zamm_yang",
            ],
        );
        if !check_yang_version() {
            eprintln!("Could not install yang v{}", YANG_DEP_VERSION);
            exit(1);
        }
    }
}

/// Build `yang` using itself.
fn main() {
    // no need to regenerate autogenerated files every time
    println!("cargo:rerun-if-changed=build.rs");
    ensure_yang_installed();

    println!("==================== RUNNING YANG ====================");
    let yang_binary = yang_path();
    assert_command(true, &yang_binary, &["build", "--yin"]);
}
